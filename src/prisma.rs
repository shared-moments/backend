// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &str =
    include_str!("../prisma/schema.prisma");
static DATABASE_STR: &str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod user {

    use super::*;
    pub const NAME: &str = "User";
    pub mod id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Email(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Email(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod password {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "password";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Password(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Password(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Password(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Password,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Password(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Password(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Name(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Name(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod partner_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "partner_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPartnerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PartnerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PartnerId(direction)
        }
        pub fn equals<A, T: ::prisma_client_rust::FromOptionalUniqueArg<Set, Arg = A>>(
            value: A,
        ) -> T {
            T::from_arg(value)
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            PartnerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPartnerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPartnerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPartnerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePartnerId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::PartnerId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::PartnerId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod partner {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "partner";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Partner(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPartner(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectPartner
        }
        pub fn is_null() -> WhereParam {
            WhereParam::PartnerIsNull
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::PartnerIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::PartnerIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Partner(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("partner", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Partner(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("partner", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod partner_of {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "partner_of";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::PartnerOf(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPartnerOf(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectPartnerOf
        }
        pub fn is_null() -> WhereParam {
            WhereParam::PartnerOfIsNull
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::PartnerOfIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::PartnerOfIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::PartnerOf(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("partner_of", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::PartnerOf(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("partner_of", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod balance {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "balance";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBalance(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Balance(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Balance(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Balance(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Balance, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBalance(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBalance(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBalance(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBalance(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Balance(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Balance(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod authored_tasks {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "authored_tasks";
        pub struct Fetch(pub task::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AuthoredTasks(v)
            }
        }
        pub fn fetch(params: Vec<task::WhereParam>) -> Fetch {
            Fetch(task::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthoredTasks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAuthoredTasks(params)
        }
        pub fn set(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::SetAuthoredTasks(params)
        }
        pub fn some(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AuthoredTasksSome(value)
        }
        pub fn every(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AuthoredTasksEvery(value)
        }
        pub fn none(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AuthoredTasksNone(value)
        }
        pub enum Include {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthoredTasks(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task::ManyArgs,
                nested_selections: Vec<task::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthoredTasks(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task::ManyArgs,
                nested_selections: Vec<task::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod as_executor_tasks {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "as_executor_tasks";
        pub struct Fetch(pub task::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AsExecutorTasks(v)
            }
        }
        pub fn fetch(params: Vec<task::WhereParam>) -> Fetch {
            Fetch(task::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAsExecutorTasks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAsExecutorTasks(params)
        }
        pub fn set(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::SetAsExecutorTasks(params)
        }
        pub fn some(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AsExecutorTasksSome(value)
        }
        pub fn every(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AsExecutorTasksEvery(value)
        }
        pub fn none(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::AsExecutorTasksNone(value)
        }
        pub enum Include {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AsExecutorTasks(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task::ManyArgs,
                nested_selections: Vec<task::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AsExecutorTasks(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task::ManyArgs,
                nested_selections: Vec<task::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod executed_tasks {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "executed_tasks";
        pub struct Fetch(pub task_execute_log::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_log::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_log::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_log::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ExecutedTasks(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_log::WhereParam>) -> Fetch {
            Fetch(task_execute_log::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_log::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecutedTasks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_log::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectExecutedTasks(params)
        }
        pub fn set(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::SetExecutedTasks(params)
        }
        pub fn some(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecutedTasksSome(value)
        }
        pub fn every(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecutedTasksEvery(value)
        }
        pub fn none(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecutedTasksNone(value)
        }
        pub enum Include {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecutedTasks(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecutedTasks(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod as_executed_tasks_approver {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "as_executed_tasks_approver";
        pub struct Fetch(pub task_execute_log::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_log::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_log::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_log::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AsExecutedTasksApprover(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_log::WhereParam>) -> Fetch {
            Fetch(task_execute_log::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_log::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAsExecutedTasksApprover(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_log::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAsExecutedTasksApprover(params)
        }
        pub fn set(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::SetAsExecutedTasksApprover(params)
        }
        pub fn some(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::AsExecutedTasksApproverSome(value)
        }
        pub fn every(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::AsExecutedTasksApproverEvery(value)
        }
        pub fn none(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::AsExecutedTasksApproverNone(value)
        }
        pub enum Include {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AsExecutedTasksApprover(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AsExecutedTasksApprover(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod as_request_executor {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "as_request_executor";
        pub struct Fetch(pub task_execute_request::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_request::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_request::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AsRequestExecutor(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_request::WhereParam>) -> Fetch {
            Fetch(task_execute_request::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_request::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAsRequestExecutor(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_request::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAsRequestExecutor(params)
        }
        pub fn set(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::SetAsRequestExecutor(params)
        }
        pub fn some(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestExecutorSome(value)
        }
        pub fn every(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestExecutorEvery(value)
        }
        pub fn none(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestExecutorNone(value)
        }
        pub enum Include {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AsRequestExecutor(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AsRequestExecutor(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod as_request_approver {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "as_request_approver";
        pub struct Fetch(pub task_execute_request::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_request::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_request::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AsRequestApprover(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_request::WhereParam>) -> Fetch {
            Fetch(task_execute_request::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_request::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAsRequestApprover(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_request::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAsRequestApprover(params)
        }
        pub fn set(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::SetAsRequestApprover(params)
        }
        pub fn some(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestApproverSome(value)
        }
        pub fn every(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestApproverEvery(value)
        }
        pub fn none(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::AsRequestApproverNone(value)
        }
        pub enum Include {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AsRequestApprover(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AsRequestApprover(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod invites {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "invites";
        pub struct Fetch(pub invite::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<invite::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: invite::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: invite::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Invites(v)
            }
        }
        pub fn fetch(params: Vec<invite::WhereParam>) -> Fetch {
            Fetch(invite::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<invite::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectInvites(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<invite::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<invite::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectInvites(params)
        }
        pub fn set(params: Vec<invite::UniqueWhereParam>) -> SetParam {
            SetParam::SetInvites(params)
        }
        pub fn some(value: Vec<invite::WhereParam>) -> WhereParam {
            WhereParam::InvitesSome(value)
        }
        pub fn every(value: Vec<invite::WhereParam>) -> WhereParam {
            WhereParam::InvitesEvery(value)
        }
        pub fn none(value: Vec<invite::WhereParam>) -> WhereParam {
            WhereParam::InvitesNone(value)
        }
        pub enum Include {
            Select(invite::ManyArgs, Vec<invite::SelectParam>),
            Include(invite::ManyArgs, Vec<invite::IncludeParam>),
            Fetch(invite::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Invites(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <invite::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <invite::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: invite::ManyArgs,
                nested_selections: Vec<invite::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: invite::ManyArgs,
                nested_selections: Vec<invite::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(invite::ManyArgs, Vec<invite::SelectParam>),
            Include(invite::ManyArgs, Vec<invite::IncludeParam>),
            Fetch(invite::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Invites(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <invite::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: invite::ManyArgs,
                nested_selections: Vec<invite::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: invite::ManyArgs,
                nested_selections: Vec<invite::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        email: String,
        password: String,
        name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (email, password, name, _params)
    }
    pub fn create_unchecked(
        email: String,
        password: String,
        name: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (email, password, name, _params)
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , email , password , name , partner_id , partner , partner_of , balance , authored_tasks , as_executor_tasks , executed_tasks , as_executed_tasks_approver , as_request_executor , as_request_approver , invites } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "email" , "password" , "name" , "partner_id" , "partner" , "partner_of" , "balance" , "authored_tasks" , "as_executor_tasks" , "executed_tasks" , "as_executed_tasks_approver" , "as_request_executor" , "as_request_approver" , "invites"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; email) => { String } ; (@ field_type ; password) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; partner_id) => { Option < i32 > } ; (@ field_type ; partner : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < partner :: Data > } ; (@ field_type ; partner) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; partner_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < partner_of :: Data > } ; (@ field_type ; partner_of) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; balance) => { i32 } ; (@ field_type ; authored_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < authored_tasks :: Data > } ; (@ field_type ; authored_tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; as_executor_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_executor_tasks :: Data > } ; (@ field_type ; as_executor_tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; executed_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < executed_tasks :: Data > } ; (@ field_type ; executed_tasks) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; as_executed_tasks_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_executed_tasks_approver :: Data > } ; (@ field_type ; as_executed_tasks_approver) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; as_request_executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_request_executor :: Data > } ; (@ field_type ; as_request_executor) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; as_request_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_request_approver :: Data > } ; (@ field_type ; as_request_approver) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; invites : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < invites :: Data > } ; (@ field_type ; invites) => { Vec < crate :: prisma :: invite :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "id, email, password, name, partner_id, partner, partner_of, balance, authored_tasks, as_executor_tasks, executed_tasks, as_executed_tasks_approver, as_request_executor, as_request_approver, invites")) } ; (@ field_module ; partner : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; partner_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; authored_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_executor_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executed_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_executed_tasks_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_request_executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_request_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; invites : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: invite :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; password) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: password :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: name :: Select) } ; (@ selection_field_to_selection_param ; partner_id) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: partner_id :: Select) } ; (@ selection_field_to_selection_param ; partner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: partner :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; partner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: partner :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; partner_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: partner_of :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; partner_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: partner_of :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; balance) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: balance :: Select) } ; (@ selection_field_to_selection_param ; authored_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: authored_tasks :: Select :: $ selection_mode (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; authored_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: authored_tasks :: Select :: Fetch (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_executor_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_executor_tasks :: Select :: $ selection_mode (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_executor_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_executor_tasks :: Select :: Fetch (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; executed_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: executed_tasks :: Select :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executed_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: executed_tasks :: Select :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_executed_tasks_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_executed_tasks_approver :: Select :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_executed_tasks_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_executed_tasks_approver :: Select :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_request_executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_request_executor :: Select :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_request_executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_request_executor :: Select :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_request_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_request_approver :: Select :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_request_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: as_request_approver :: Select :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; invites $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: invites :: Select :: $ selection_mode (crate :: prisma :: invite :: ManyArgs :: new (crate :: prisma :: invite :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: invite :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; invites $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: invites :: Select :: Fetch (crate :: prisma :: invite :: ManyArgs :: new (crate :: prisma :: invite :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; partner_id) => { "partner_id" } ; (@ field_serde_name ; partner) => { "partner" } ; (@ field_serde_name ; partner_of) => { "partner_of" } ; (@ field_serde_name ; balance) => { "balance" } ; (@ field_serde_name ; authored_tasks) => { "authored_tasks" } ; (@ field_serde_name ; as_executor_tasks) => { "as_executor_tasks" } ; (@ field_serde_name ; executed_tasks) => { "executed_tasks" } ; (@ field_serde_name ; as_executed_tasks_approver) => { "as_executed_tasks_approver" } ; (@ field_serde_name ; as_request_executor) => { "as_request_executor" } ; (@ field_serde_name ; as_request_approver) => { "as_request_approver" } ; (@ field_serde_name ; invites) => { "invites" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Id(id::Select),
        Email(email::Select),
        Password(password::Select),
        Name(name::Select),
        PartnerId(partner_id::Select),
        Partner(partner::Select),
        PartnerOf(partner_of::Select),
        Balance(balance::Select),
        AuthoredTasks(authored_tasks::Select),
        AsExecutorTasks(as_executor_tasks::Select),
        ExecutedTasks(executed_tasks::Select),
        AsExecutedTasksApprover(as_executed_tasks_approver::Select),
        AsRequestExecutor(as_request_executor::Select),
        AsRequestApprover(as_request_approver::Select),
        Invites(invites::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::PartnerId(data) => data.to_selection(),
                Self::Partner(data) => data.to_selection(),
                Self::PartnerOf(data) => data.to_selection(),
                Self::Balance(data) => data.to_selection(),
                Self::AuthoredTasks(data) => data.to_selection(),
                Self::AsExecutorTasks(data) => data.to_selection(),
                Self::ExecutedTasks(data) => data.to_selection(),
                Self::AsExecutedTasksApprover(data) => data.to_selection(),
                Self::AsRequestExecutor(data) => data.to_selection(),
                Self::AsRequestApprover(data) => data.to_selection(),
                Self::Invites(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { partner , partner_of , authored_tasks , as_executor_tasks , executed_tasks , as_executed_tasks_approver , as_request_executor , as_request_approver , invites } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub email : String , pub password : String , pub name : String , pub partner_id : Option < i32 > , pub balance : i32 , $ (pub $ field : crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (email) , stringify ! (password) , stringify ! (name) , stringify ! (partner_id) , stringify ! (balance)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: user :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: user :: password :: NAME , & self . password) ? ; state . serialize_field (crate :: prisma :: user :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: user :: partner_id :: NAME , & self . partner_id) ? ; state . serialize_field (crate :: prisma :: user :: balance :: NAME , & self . balance) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , email , password , name , partner_id , balance } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + , crate :: prisma :: user :: id :: NAME , crate :: prisma :: user :: email :: NAME , crate :: prisma :: user :: password :: NAME , crate :: prisma :: user :: name :: NAME , crate :: prisma :: user :: partner_id :: NAME , crate :: prisma :: user :: balance :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user :: id :: NAME => Ok (Field :: id) , crate :: prisma :: user :: email :: NAME => Ok (Field :: email) , crate :: prisma :: user :: password :: NAME => Ok (Field :: password) , crate :: prisma :: user :: name :: NAME => Ok (Field :: name) , crate :: prisma :: user :: partner_id :: NAME => Ok (Field :: partner_id) , crate :: prisma :: user :: balance :: NAME => Ok (Field :: balance) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut email = None ; let mut password = None ; let mut name = None ; let mut partner_id = None ; let mut balance = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: password => { if password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: password :: NAME)) ; } password = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: partner_id => { if partner_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: partner_id :: NAME)) ; } partner_id = Some (map . next_value () ?) ; } Field :: balance => { if balance . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: balance :: NAME)) ; } balance = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: id :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: email :: NAME)) ? ; let password = password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: password :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: name :: NAME)) ? ; let partner_id = partner_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: partner_id :: NAME)) ? ; let balance = balance . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: balance :: NAME)) ? ; Ok (Data { id , email , password , name , partner_id , balance , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "email" , "password" , "name" , "partner_id" , "partner" , "partner_of" , "balance" , "authored_tasks" , "as_executor_tasks" , "executed_tasks" , "as_executed_tasks_approver" , "as_request_executor" , "as_request_approver" , "invites"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; partner : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < partner :: Data > } ; (@ field_type ; partner) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; partner_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < partner_of :: Data > } ; (@ field_type ; partner_of) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; authored_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < authored_tasks :: Data > } ; (@ field_type ; authored_tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; as_executor_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_executor_tasks :: Data > } ; (@ field_type ; as_executor_tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; executed_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < executed_tasks :: Data > } ; (@ field_type ; executed_tasks) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; as_executed_tasks_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_executed_tasks_approver :: Data > } ; (@ field_type ; as_executed_tasks_approver) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; as_request_executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_request_executor :: Data > } ; (@ field_type ; as_request_executor) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; as_request_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < as_request_approver :: Data > } ; (@ field_type ; as_request_approver) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; invites : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < invites :: Data > } ; (@ field_type ; invites) => { Vec < crate :: prisma :: invite :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "partner, partner_of, authored_tasks, as_executor_tasks, executed_tasks, as_executed_tasks_approver, as_request_executor, as_request_approver, invites")) } ; (@ field_module ; partner : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; partner_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; authored_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_executor_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executed_tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_executed_tasks_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_request_executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; as_request_approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; invites : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: invite :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; partner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: partner :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; partner $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: partner :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; partner_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: partner_of :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; partner_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: partner_of :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; authored_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: authored_tasks :: Include :: $ selection_mode (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; authored_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: authored_tasks :: Include :: Fetch (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_executor_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_executor_tasks :: Include :: $ selection_mode (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_executor_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_executor_tasks :: Include :: Fetch (crate :: prisma :: task :: ManyArgs :: new (crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; executed_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: executed_tasks :: Include :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executed_tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: executed_tasks :: Include :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_executed_tasks_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_executed_tasks_approver :: Include :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_executed_tasks_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_executed_tasks_approver :: Include :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_request_executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_request_executor :: Include :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_request_executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_request_executor :: Include :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; as_request_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_request_approver :: Include :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; as_request_approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: as_request_approver :: Include :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; invites $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: invites :: Include :: $ selection_mode (crate :: prisma :: invite :: ManyArgs :: new (crate :: prisma :: invite :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: invite :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; invites $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user :: IncludeParam > :: into (crate :: prisma :: user :: invites :: Include :: Fetch (crate :: prisma :: invite :: ManyArgs :: new (crate :: prisma :: invite :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; partner_id) => { "partner_id" } ; (@ field_serde_name ; partner) => { "partner" } ; (@ field_serde_name ; partner_of) => { "partner_of" } ; (@ field_serde_name ; balance) => { "balance" } ; (@ field_serde_name ; authored_tasks) => { "authored_tasks" } ; (@ field_serde_name ; as_executor_tasks) => { "as_executor_tasks" } ; (@ field_serde_name ; executed_tasks) => { "executed_tasks" } ; (@ field_serde_name ; as_executed_tasks_approver) => { "as_executed_tasks_approver" } ; (@ field_serde_name ; as_request_executor) => { "as_request_executor" } ; (@ field_serde_name ; as_request_approver) => { "as_request_approver" } ; (@ field_serde_name ; invites) => { "invites" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Id(id::Include),
        Email(email::Include),
        Password(password::Include),
        Name(name::Include),
        PartnerId(partner_id::Include),
        Partner(partner::Include),
        PartnerOf(partner_of::Include),
        Balance(balance::Include),
        AuthoredTasks(authored_tasks::Include),
        AsExecutorTasks(as_executor_tasks::Include),
        ExecutedTasks(executed_tasks::Include),
        AsExecutedTasksApprover(as_executed_tasks_approver::Include),
        AsRequestExecutor(as_request_executor::Include),
        AsRequestApprover(as_request_approver::Include),
        Invites(invites::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::PartnerId(data) => data.to_selection(),
                Self::Partner(data) => data.to_selection(),
                Self::PartnerOf(data) => data.to_selection(),
                Self::Balance(data) => data.to_selection(),
                Self::AuthoredTasks(data) => data.to_selection(),
                Self::AsExecutorTasks(data) => data.to_selection(),
                Self::ExecutedTasks(data) => data.to_selection(),
                Self::AsExecutedTasksApprover(data) => data.to_selection(),
                Self::AsRequestExecutor(data) => data.to_selection(),
                Self::AsRequestApprover(data) => data.to_selection(),
                Self::Invites(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_user { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: user struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "email")] pub email : String , # [serde (rename = "password")] pub password : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "partner_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub partner_id : Option < i32 > , # [serde (rename = "balance")] pub balance : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "password")]
        pub password: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "partner_id")]
        pub partner_id: Option<i32>,
        #[serde(
            rename = "partner",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub partner: Option<Option<Box<super::user::Data>>>,
        #[serde(
            rename = "partner_of",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub partner_of: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "balance")]
        pub balance: i32,
        #[serde(rename = "authored_tasks")]
        pub authored_tasks: Option<Vec<super::task::Data>>,
        #[serde(rename = "as_executor_tasks")]
        pub as_executor_tasks: Option<Vec<super::task::Data>>,
        #[serde(rename = "executed_tasks")]
        pub executed_tasks: Option<Vec<super::task_execute_log::Data>>,
        #[serde(rename = "as_executed_tasks_approver")]
        pub as_executed_tasks_approver: Option<Vec<super::task_execute_log::Data>>,
        #[serde(rename = "as_request_executor")]
        pub as_request_executor: Option<Vec<super::task_execute_request::Data>>,
        #[serde(rename = "as_request_approver")]
        pub as_request_approver: Option<Vec<super::task_execute_request::Data>>,
        #[serde(rename = "invites")]
        pub invites: Option<Vec<super::invite::Data>>,
    }
    impl Data {
        pub fn partner(
            &self,
        ) -> Result<Option<&super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.partner
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(partner),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn partner_of(
            &self,
        ) -> Result<Option<&super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.partner_of
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(partner_of),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn authored_tasks(
            &self,
        ) -> Result<&Vec<super::task::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.authored_tasks
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(authored_tasks),
                ))
        }
        pub fn as_executor_tasks(
            &self,
        ) -> Result<&Vec<super::task::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.as_executor_tasks.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(as_executor_tasks)),
            )
        }
        pub fn executed_tasks(
            &self,
        ) -> Result<
            &Vec<super::task_execute_log::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.executed_tasks
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(executed_tasks),
                ))
        }
        pub fn as_executed_tasks_approver(
            &self,
        ) -> Result<
            &Vec<super::task_execute_log::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.as_executed_tasks_approver.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    as_executed_tasks_approver
                )),
            )
        }
        pub fn as_request_executor(
            &self,
        ) -> Result<
            &Vec<super::task_execute_request::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.as_request_executor.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(as_request_executor)),
            )
        }
        pub fn as_request_approver(
            &self,
        ) -> Result<
            &Vec<super::task_execute_request::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.as_request_approver.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(as_request_approver)),
            )
        }
        pub fn invites(
            &self,
        ) -> Result<&Vec<super::invite::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.invites
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(invites),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Partner(super::user::UniqueArgs),
        PartnerOf(super::user::UniqueArgs),
        AuthoredTasks(super::task::ManyArgs),
        AsExecutorTasks(super::task::ManyArgs),
        ExecutedTasks(super::task_execute_log::ManyArgs),
        AsExecutedTasksApprover(super::task_execute_log::ManyArgs),
        AsRequestExecutor(super::task_execute_request::ManyArgs),
        AsRequestApprover(super::task_execute_request::ManyArgs),
        Invites(super::invite::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Partner(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(partner::NAME, None, [], selections)
                }
                WithParam::PartnerOf(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(partner_of::NAME, None, [], selections)
                }
                WithParam::AuthoredTasks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        authored_tasks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::AsExecutorTasks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        as_executor_tasks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::ExecutedTasks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        executed_tasks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::AsExecutedTasksApprover(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        as_executed_tasks_approver::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::AsRequestExecutor(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        as_request_executor::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::AsRequestApprover(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        as_request_approver::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Invites(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: invite :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        invites::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetEmail(String),
        SetPassword(String),
        SetName(String),
        SetPartnerId(Option<i32>),
        IncrementPartnerId(i32),
        DecrementPartnerId(i32),
        MultiplyPartnerId(i32),
        DividePartnerId(i32),
        ConnectPartner(super::user::UniqueWhereParam),
        DisconnectPartner,
        ConnectPartnerOf(super::user::UniqueWhereParam),
        DisconnectPartnerOf,
        SetBalance(i32),
        IncrementBalance(i32),
        DecrementBalance(i32),
        MultiplyBalance(i32),
        DivideBalance(i32),
        ConnectAuthoredTasks(Vec<super::task::UniqueWhereParam>),
        DisconnectAuthoredTasks(Vec<super::task::UniqueWhereParam>),
        SetAuthoredTasks(Vec<super::task::UniqueWhereParam>),
        ConnectAsExecutorTasks(Vec<super::task::UniqueWhereParam>),
        DisconnectAsExecutorTasks(Vec<super::task::UniqueWhereParam>),
        SetAsExecutorTasks(Vec<super::task::UniqueWhereParam>),
        ConnectExecutedTasks(Vec<super::task_execute_log::UniqueWhereParam>),
        DisconnectExecutedTasks(Vec<super::task_execute_log::UniqueWhereParam>),
        SetExecutedTasks(Vec<super::task_execute_log::UniqueWhereParam>),
        ConnectAsExecutedTasksApprover(Vec<super::task_execute_log::UniqueWhereParam>),
        DisconnectAsExecutedTasksApprover(Vec<super::task_execute_log::UniqueWhereParam>),
        SetAsExecutedTasksApprover(Vec<super::task_execute_log::UniqueWhereParam>),
        ConnectAsRequestExecutor(Vec<super::task_execute_request::UniqueWhereParam>),
        DisconnectAsRequestExecutor(Vec<super::task_execute_request::UniqueWhereParam>),
        SetAsRequestExecutor(Vec<super::task_execute_request::UniqueWhereParam>),
        ConnectAsRequestApprover(Vec<super::task_execute_request::UniqueWhereParam>),
        DisconnectAsRequestApprover(Vec<super::task_execute_request::UniqueWhereParam>),
        SetAsRequestApprover(Vec<super::task_execute_request::UniqueWhereParam>),
        ConnectInvites(Vec<super::invite::UniqueWhereParam>),
        DisconnectInvites(Vec<super::invite::UniqueWhereParam>),
        SetInvites(Vec<super::invite::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPassword(value) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPartnerId(value) => (
                    partner_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementPartnerId(value) => (
                    partner_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPartnerId(value) => (
                    partner_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPartnerId(value) => (
                    partner_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePartnerId(value) => (
                    partner_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectPartner(where_param) => (
                    partner::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectPartner => (
                    partner::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectPartnerOf(where_param) => (
                    partner_of::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectPartnerOf => (
                    partner_of::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBalance(value) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAuthoredTasks(where_params) => (
                    authored_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuthoredTasks(where_params) => (
                    authored_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuthoredTasks(where_params) => (
                    authored_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAsExecutorTasks(where_params) => (
                    as_executor_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAsExecutorTasks(where_params) => (
                    as_executor_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAsExecutorTasks(where_params) => (
                    as_executor_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectExecutedTasks(where_params) => (
                    executed_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectExecutedTasks(where_params) => (
                    executed_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExecutedTasks(where_params) => (
                    executed_tasks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAsExecutedTasksApprover(where_params) => (
                    as_executed_tasks_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAsExecutedTasksApprover(where_params) => (
                    as_executed_tasks_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAsExecutedTasksApprover(where_params) => (
                    as_executed_tasks_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAsRequestExecutor(where_params) => (
                    as_request_executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAsRequestExecutor(where_params) => (
                    as_request_executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAsRequestExecutor(where_params) => (
                    as_request_executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAsRequestApprover(where_params) => (
                    as_request_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAsRequestApprover(where_params) => (
                    as_request_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAsRequestApprover(where_params) => (
                    as_request_approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectInvites(where_params) => (
                    invites::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::invite::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectInvites(where_params) => (
                    invites::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::invite::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetInvites(where_params) => (
                    invites::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::invite::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Email(String),
        Password(String),
        Name(String),
        PartnerId(Option<i32>),
        Balance(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::Password(value) => Self::SetPassword(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::PartnerId(value) => Self::SetPartnerId(value),
                UncheckedSetParam::Balance(value) => Self::SetBalance(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        Password(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        PartnerId(::prisma_client_rust::Direction),
        Balance(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Password(direction) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::PartnerId(direction) => (
                    partner_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Balance(direction) => (
                    balance::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Email(_prisma::read_filters::StringFilter),
        Password(_prisma::read_filters::StringFilter),
        Name(_prisma::read_filters::StringFilter),
        PartnerId(_prisma::read_filters::IntNullableFilter),
        PartnerIsNull,
        PartnerIs(Vec<super::user::WhereParam>),
        PartnerIsNot(Vec<super::user::WhereParam>),
        PartnerOfIsNull,
        PartnerOfIs(Vec<super::user::WhereParam>),
        PartnerOfIsNot(Vec<super::user::WhereParam>),
        Balance(_prisma::read_filters::IntFilter),
        AuthoredTasksSome(Vec<super::task::WhereParam>),
        AuthoredTasksEvery(Vec<super::task::WhereParam>),
        AuthoredTasksNone(Vec<super::task::WhereParam>),
        AsExecutorTasksSome(Vec<super::task::WhereParam>),
        AsExecutorTasksEvery(Vec<super::task::WhereParam>),
        AsExecutorTasksNone(Vec<super::task::WhereParam>),
        ExecutedTasksSome(Vec<super::task_execute_log::WhereParam>),
        ExecutedTasksEvery(Vec<super::task_execute_log::WhereParam>),
        ExecutedTasksNone(Vec<super::task_execute_log::WhereParam>),
        AsExecutedTasksApproverSome(Vec<super::task_execute_log::WhereParam>),
        AsExecutedTasksApproverEvery(Vec<super::task_execute_log::WhereParam>),
        AsExecutedTasksApproverNone(Vec<super::task_execute_log::WhereParam>),
        AsRequestExecutorSome(Vec<super::task_execute_request::WhereParam>),
        AsRequestExecutorEvery(Vec<super::task_execute_request::WhereParam>),
        AsRequestExecutorNone(Vec<super::task_execute_request::WhereParam>),
        AsRequestApproverSome(Vec<super::task_execute_request::WhereParam>),
        AsRequestApproverEvery(Vec<super::task_execute_request::WhereParam>),
        AsRequestApproverNone(Vec<super::task_execute_request::WhereParam>),
        InvitesSome(Vec<super::invite::WhereParam>),
        InvitesEvery(Vec<super::invite::WhereParam>),
        InvitesNone(Vec<super::invite::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::Password(value) => (password::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::PartnerId(value) => (partner_id::NAME, value.into()),
                Self::PartnerIsNull => (
                    partner::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::PartnerIs(where_params) => (
                    partner::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PartnerIsNot(where_params) => (
                    partner::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PartnerOfIsNull => (
                    partner_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::PartnerOfIs(where_params) => (
                    partner_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PartnerOfIsNot(where_params) => (
                    partner_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Balance(value) => (balance::NAME, value.into()),
                Self::AuthoredTasksSome(where_params) => (
                    authored_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthoredTasksEvery(where_params) => (
                    authored_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthoredTasksNone(where_params) => (
                    authored_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutorTasksSome(where_params) => (
                    as_executor_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutorTasksEvery(where_params) => (
                    as_executor_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutorTasksNone(where_params) => (
                    as_executor_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutedTasksSome(where_params) => (
                    executed_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutedTasksEvery(where_params) => (
                    executed_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutedTasksNone(where_params) => (
                    executed_tasks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutedTasksApproverSome(where_params) => (
                    as_executed_tasks_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutedTasksApproverEvery(where_params) => (
                    as_executed_tasks_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsExecutedTasksApproverNone(where_params) => (
                    as_executed_tasks_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestExecutorSome(where_params) => (
                    as_request_executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestExecutorEvery(where_params) => (
                    as_request_executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestExecutorNone(where_params) => (
                    as_request_executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestApproverSome(where_params) => (
                    as_request_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestApproverEvery(where_params) => (
                    as_request_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AsRequestApproverNone(where_params) => (
                    as_request_approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvitesSome(where_params) => (
                    invites::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvitesEvery(where_params) => (
                    invites::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::InvitesNone(where_params) => (
                    invites::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailEquals(String),
        PartnerIdEquals(i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => {
                    Self::Email(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::PartnerIdEquals(value) => Self::PartnerId(
                    _prisma::read_filters::IntNullableFilter::Equals(Some(value)),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<partner_id::Set> for WhereParam {
        type Arg = Option<i32>;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::PartnerId(_prisma::read_filters::IntNullableFilter::Equals(arg))
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<partner_id::Set> for UniqueWhereParam {
        type Arg = i32;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::PartnerIdEquals(arg)
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(password::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(partner_id::NAME),
                ::prisma_client_rust::sel(balance::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            email: String,
            password: String,
            name: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([email::set(email), password::set(password), name::set(name)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            email: String,
            password: String,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([email::set(email), password::set(password), name::set(name)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(email, password, name, mut _params)| {
                    _params.extend([email::set(email), password::set(password), name::set(name)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (email, password, name, mut _params): (String, String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([email::set(email), password::set(password), name::set(name)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod invite {

    use super::*;
    pub const NAME: &str = "Invite";
    pub mod id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod from_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "from_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFromId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FromId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FromId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::FromId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, FromId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFromId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFromId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFromId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFromId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::FromId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::FromId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod from {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "from";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::From(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFrom(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FromIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::FromIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::From(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("from", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::From(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("from", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod token {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "token";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Token(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Token(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::TokenEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Token,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Token(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Token(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        from: super::user::UniqueWhereParam,
        token: String,
        _params: Vec<SetParam>,
    ) -> (super::user::UniqueWhereParam, String, Vec<SetParam>) {
        (from, token, _params)
    }
    pub fn create_unchecked(
        from_id: i32,
        token: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, Vec<SetParam>) {
        (from_id, token, _params)
    }
    #[macro_export]
    macro_rules ! _select_invite { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: invite :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: invite :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: invite :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $crate :: prisma :: invite :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: invite :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: invite :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , from_id , from , token } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: invite :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: invite :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: invite :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: invite :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: invite :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: invite :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "from_id" , "from" , "token"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: invite :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; from_id) => { i32 } ; (@ field_type ; from : $ selection_mode : ident { $ ($ selections : tt) + }) => { from :: Data } ; (@ field_type ; from) => { crate :: prisma :: user :: Data } ; (@ field_type ; token) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Invite" , available relations are "id, from_id, from, token")) } ; (@ field_module ; from : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: invite :: SelectParam > :: into (crate :: prisma :: invite :: id :: Select) } ; (@ selection_field_to_selection_param ; from_id) => { Into :: < crate :: prisma :: invite :: SelectParam > :: into (crate :: prisma :: invite :: from_id :: Select) } ; (@ selection_field_to_selection_param ; from $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: invite :: SelectParam > :: into (crate :: prisma :: invite :: from :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; from $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: invite :: SelectParam > :: into (crate :: prisma :: invite :: from :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; token) => { Into :: < crate :: prisma :: invite :: SelectParam > :: into (crate :: prisma :: invite :: token :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: invite :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; from_id) => { "from_id" } ; (@ field_serde_name ; from) => { "from" } ; (@ field_serde_name ; token) => { "token" } ; }
    pub use _select_invite as select;
    pub enum SelectParam {
        Id(id::Select),
        FromId(from_id::Select),
        From(from::Select),
        Token(token::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::FromId(data) => data.to_selection(),
                Self::From(data) => data.to_selection(),
                Self::Token(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_invite { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: invite :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: invite :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: invite :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $crate :: prisma :: invite :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: invite :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: invite :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: invite :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: invite :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { from } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub from_id : i32 , pub token : String , $ (pub $ field : crate :: prisma :: invite :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (from_id) , stringify ! (token)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: invite :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: invite :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: invite :: from_id :: NAME , & self . from_id) ? ; state . serialize_field (crate :: prisma :: invite :: token :: NAME , & self . token) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , from_id , token } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: invite :: $ field :: NAME) , + , crate :: prisma :: invite :: id :: NAME , crate :: prisma :: invite :: from_id :: NAME , crate :: prisma :: invite :: token :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: invite :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: invite :: id :: NAME => Ok (Field :: id) , crate :: prisma :: invite :: from_id :: NAME => Ok (Field :: from_id) , crate :: prisma :: invite :: token :: NAME => Ok (Field :: token) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut from_id = None ; let mut token = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: invite :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: from_id => { if from_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: invite :: from_id :: NAME)) ; } from_id = Some (map . next_value () ?) ; } Field :: token => { if token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: invite :: token :: NAME)) ; } token = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: invite :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: invite :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: invite :: id :: NAME)) ? ; let from_id = from_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: invite :: from_id :: NAME)) ? ; let token = token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: invite :: token :: NAME)) ? ; Ok (Data { id , from_id , token , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "from_id" , "from" , "token"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: invite :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; from : $ selection_mode : ident { $ ($ selections : tt) + }) => { from :: Data } ; (@ field_type ; from) => { crate :: prisma :: user :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Invite" , available relations are "from")) } ; (@ field_module ; from : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; from $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: invite :: IncludeParam > :: into (crate :: prisma :: invite :: from :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; from $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: invite :: IncludeParam > :: into (crate :: prisma :: invite :: from :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: invite :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; from_id) => { "from_id" } ; (@ field_serde_name ; from) => { "from" } ; (@ field_serde_name ; token) => { "token" } ; }
    pub use _include_invite as include;
    pub enum IncludeParam {
        Id(id::Include),
        FromId(from_id::Include),
        From(from::Include),
        Token(token::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::FromId(data) => data.to_selection(),
                Self::From(data) => data.to_selection(),
                Self::Token(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_invite { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: invite struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "from_id")] pub from_id : i32 , # [serde (rename = "token")] pub token : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_invite as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "from_id")]
        pub from_id: i32,
        #[serde(rename = "from")]
        pub from: Option<Box<super::user::Data>>,
        #[serde(rename = "token")]
        pub token: String,
    }
    impl Data {
        pub fn from(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.from
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(from),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        From(super::user::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::From(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(from::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetFromId(i32),
        IncrementFromId(i32),
        DecrementFromId(i32),
        MultiplyFromId(i32),
        DivideFromId(i32),
        ConnectFrom(super::user::UniqueWhereParam),
        SetToken(String),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFromId(value) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementFromId(value) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFromId(value) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFromId(value) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFromId(value) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectFrom(where_param) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetToken(value) => (
                    token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        FromId(i32),
        Token(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::FromId(value) => Self::SetFromId(value),
                UncheckedSetParam::Token(value) => Self::SetToken(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        FromId(::prisma_client_rust::Direction),
        Token(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::FromId(direction) => (
                    from_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Token(direction) => (
                    token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        FromId(_prisma::read_filters::IntFilter),
        FromIs(Vec<super::user::WhereParam>),
        FromIsNot(Vec<super::user::WhereParam>),
        Token(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::FromId(value) => (from_id::NAME, value.into()),
                Self::FromIs(where_params) => (
                    from::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FromIsNot(where_params) => (
                    from::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Token(value) => (token::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        TokenEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::TokenEquals(value) => {
                    Self::Token(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(from_id::NAME),
                ::prisma_client_rust::sel(token::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            from: super::user::UniqueWhereParam,
            token: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([from::connect(from), token::set(token)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            from_id: i32,
            token: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([from_id::set(from_id), token::set(token)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(from_id, token, mut _params)| {
                    _params.extend([from_id::set(from_id), token::set(token)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (from, token, mut _params): (super::user::UniqueWhereParam, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([from::connect(from), token::set(token)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod task {

    use super::*;
    pub const NAME: &str = "Task";
    pub mod id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Title(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Title(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod description {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "description";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDescription(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Description,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Description(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Description(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod price {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "price";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPrice(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Price(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Price(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Price(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Price, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPrice(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPrice(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPrice(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePrice(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Price(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Price(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::CreatedAt(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::CreatedAt(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "updated_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::UpdatedAt(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::UpdatedAt(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_need_request {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "is_need_request";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsNeedRequest(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsNeedRequest(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsNeedRequest(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsNeedRequest(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsNeedRequest,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::IsNeedRequest(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::IsNeedRequest(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_enabled {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "is_enabled";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsEnabled(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsEnabled(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsEnabled(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsEnabled(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsEnabled,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::IsEnabled(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::IsEnabled(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "author_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAuthorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAuthorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAuthorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAuthorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Author(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Author(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod executor_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "executor_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExecutorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExecutorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExecutorId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ExecutorId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ExecutorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementExecutorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementExecutorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyExecutorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideExecutorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecutorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecutorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod executor {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "executor";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Executor(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecutor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectExecutor
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ExecutorIsNull
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Executor(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Executor(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod execute_logs {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "execute_logs";
        pub struct Fetch(pub task_execute_log::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_log::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_log::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_log::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ExecuteLogs(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_log::WhereParam>) -> Fetch {
            Fetch(task_execute_log::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_log::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecuteLogs(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_log::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectExecuteLogs(params)
        }
        pub fn set(params: Vec<task_execute_log::UniqueWhereParam>) -> SetParam {
            SetParam::SetExecuteLogs(params)
        }
        pub fn some(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecuteLogsSome(value)
        }
        pub fn every(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecuteLogsEvery(value)
        }
        pub fn none(value: Vec<task_execute_log::WhereParam>) -> WhereParam {
            WhereParam::ExecuteLogsNone(value)
        }
        pub enum Include {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecuteLogs(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::SelectParam>,
            ),
            Include(
                task_execute_log::ManyArgs,
                Vec<task_execute_log::IncludeParam>,
            ),
            Fetch(task_execute_log::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecuteLogs(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_log::ManyArgs,
                nested_selections: Vec<task_execute_log::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod execute_requests {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "execute_requests";
        pub struct Fetch(pub task_execute_request::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task_execute_request::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task_execute_request::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task_execute_request::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ExecuteRequests(v)
            }
        }
        pub fn fetch(params: Vec<task_execute_request::WhereParam>) -> Fetch {
            Fetch(task_execute_request::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<task_execute_request::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecuteRequests(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<task_execute_request::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectExecuteRequests(params)
        }
        pub fn set(params: Vec<task_execute_request::UniqueWhereParam>) -> SetParam {
            SetParam::SetExecuteRequests(params)
        }
        pub fn some(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::ExecuteRequestsSome(value)
        }
        pub fn every(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::ExecuteRequestsEvery(value)
        }
        pub fn none(value: Vec<task_execute_request::WhereParam>) -> WhereParam {
            WhereParam::ExecuteRequestsNone(value)
        }
        pub enum Include {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecuteRequests(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::SelectParam>,
            ),
            Include(
                task_execute_request::ManyArgs,
                Vec<task_execute_request::IncludeParam>,
            ),
            Fetch(task_execute_request::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecuteRequests(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: task_execute_request::ManyArgs,
                nested_selections: Vec<task_execute_request::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod limits {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "limits";
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLimits(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Limits(v)
            }
        }
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Limits(direction)
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Limits(_prisma::read_filters::JsonFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::JsonFilter, Limits, {
            fn path(_: Vec<String>) -> Path;
            fn string_contains(_: String) -> StringContains;
            fn string_starts_with(_: String) -> StringStartsWith;
            fn string_ends_with(_: String) -> StringEndsWith;
            fn array_contains(_: Option<::prisma_client_rust::serde_json::Value>) -> ArrayContains;
            fn array_starts_with(
                _: Option<::prisma_client_rust::serde_json::Value>,
            ) -> ArrayStartsWith;
            fn array_ends_with(_: Option<::prisma_client_rust::serde_json::Value>)
                -> ArrayEndsWith;
            fn lt(_: ::prisma_client_rust::serde_json::Value) -> Lt;
            fn lte(_: ::prisma_client_rust::serde_json::Value) -> Lte;
            fn gt(_: ::prisma_client_rust::serde_json::Value) -> Gt;
            fn gte(_: ::prisma_client_rust::serde_json::Value) -> Gte;
            fn not(_: ::prisma_client_rust::serde_json::Value) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Limits(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Limits(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        title: String,
        description: String,
        price: i32,
        author: super::user::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        i32,
        super::user::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (title, description, price, author, _params)
    }
    pub fn create_unchecked(
        title: String,
        description: String,
        price: i32,
        author_id: i32,
        _params: Vec<SetParam>,
    ) -> (String, String, i32, i32, Vec<SetParam>) {
        (title, description, price, author_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_task { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $crate :: prisma :: task :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , description , price , created_at , updated_at , is_need_request , is_enabled , author_id , author , executor_id , executor , execute_logs , execute_requests , limits } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: task :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "description" , "price" , "created_at" , "updated_at" , "is_need_request" , "is_enabled" , "author_id" , "author" , "executor_id" , "executor" , "execute_logs" , "execute_requests" , "limits"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; price) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; is_need_request) => { bool } ; (@ field_type ; is_enabled) => { bool } ; (@ field_type ; author_id) => { i32 } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: user :: Data } ; (@ field_type ; executor_id) => { Option < i32 > } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < executor :: Data > } ; (@ field_type ; executor) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; execute_logs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < execute_logs :: Data > } ; (@ field_type ; execute_logs) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; execute_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < execute_requests :: Data > } ; (@ field_type ; execute_requests) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; limits) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Task" , available relations are "id, title, description, price, created_at, updated_at, is_need_request, is_enabled, author_id, author, executor_id, executor, execute_logs, execute_requests, limits")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; execute_logs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; execute_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: title :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: description :: Select) } ; (@ selection_field_to_selection_param ; price) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: price :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; is_need_request) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: is_need_request :: Select) } ; (@ selection_field_to_selection_param ; is_enabled) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: is_enabled :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: author_id :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: author :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; executor_id) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: executor_id :: Select) } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: executor :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: executor :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; execute_logs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: execute_logs :: Select :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; execute_logs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: execute_logs :: Select :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; execute_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: execute_requests :: Select :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; execute_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: execute_requests :: Select :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; limits) => { Into :: < crate :: prisma :: task :: SelectParam > :: into (crate :: prisma :: task :: limits :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; is_need_request) => { "is_need_request" } ; (@ field_serde_name ; is_enabled) => { "is_enabled" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; execute_logs) => { "execute_logs" } ; (@ field_serde_name ; execute_requests) => { "execute_requests" } ; (@ field_serde_name ; limits) => { "limits" } ; }
    pub use _select_task as select;
    pub enum SelectParam {
        Id(id::Select),
        Title(title::Select),
        Description(description::Select),
        Price(price::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
        IsNeedRequest(is_need_request::Select),
        IsEnabled(is_enabled::Select),
        AuthorId(author_id::Select),
        Author(author::Select),
        ExecutorId(executor_id::Select),
        Executor(executor::Select),
        ExecuteLogs(execute_logs::Select),
        ExecuteRequests(execute_requests::Select),
        Limits(limits::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
                Self::IsNeedRequest(data) => data.to_selection(),
                Self::IsEnabled(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ExecuteLogs(data) => data.to_selection(),
                Self::ExecuteRequests(data) => data.to_selection(),
                Self::Limits(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_task { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $crate :: prisma :: task :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: task :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: task :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author , executor , execute_logs , execute_requests } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub title : String , pub description : String , pub price : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub is_need_request : bool , pub is_enabled : bool , pub author_id : i32 , pub executor_id : Option < i32 > , pub limits : :: prisma_client_rust :: serde_json :: Value , $ (pub $ field : crate :: prisma :: task :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (description) , stringify ! (price) , stringify ! (created_at) , stringify ! (updated_at) , stringify ! (is_need_request) , stringify ! (is_enabled) , stringify ! (author_id) , stringify ! (executor_id) , stringify ! (limits)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: task :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: task :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: prisma :: task :: description :: NAME , & self . description) ? ; state . serialize_field (crate :: prisma :: task :: price :: NAME , & self . price) ? ; state . serialize_field (crate :: prisma :: task :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: task :: updated_at :: NAME , & self . updated_at) ? ; state . serialize_field (crate :: prisma :: task :: is_need_request :: NAME , & self . is_need_request) ? ; state . serialize_field (crate :: prisma :: task :: is_enabled :: NAME , & self . is_enabled) ? ; state . serialize_field (crate :: prisma :: task :: author_id :: NAME , & self . author_id) ? ; state . serialize_field (crate :: prisma :: task :: executor_id :: NAME , & self . executor_id) ? ; state . serialize_field (crate :: prisma :: task :: limits :: NAME , & self . limits) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , description , price , created_at , updated_at , is_need_request , is_enabled , author_id , executor_id , limits } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task :: $ field :: NAME) , + , crate :: prisma :: task :: id :: NAME , crate :: prisma :: task :: title :: NAME , crate :: prisma :: task :: description :: NAME , crate :: prisma :: task :: price :: NAME , crate :: prisma :: task :: created_at :: NAME , crate :: prisma :: task :: updated_at :: NAME , crate :: prisma :: task :: is_need_request :: NAME , crate :: prisma :: task :: is_enabled :: NAME , crate :: prisma :: task :: author_id :: NAME , crate :: prisma :: task :: executor_id :: NAME , crate :: prisma :: task :: limits :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: task :: id :: NAME => Ok (Field :: id) , crate :: prisma :: task :: title :: NAME => Ok (Field :: title) , crate :: prisma :: task :: description :: NAME => Ok (Field :: description) , crate :: prisma :: task :: price :: NAME => Ok (Field :: price) , crate :: prisma :: task :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: task :: updated_at :: NAME => Ok (Field :: updated_at) , crate :: prisma :: task :: is_need_request :: NAME => Ok (Field :: is_need_request) , crate :: prisma :: task :: is_enabled :: NAME => Ok (Field :: is_enabled) , crate :: prisma :: task :: author_id :: NAME => Ok (Field :: author_id) , crate :: prisma :: task :: executor_id :: NAME => Ok (Field :: executor_id) , crate :: prisma :: task :: limits :: NAME => Ok (Field :: limits) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut description = None ; let mut price = None ; let mut created_at = None ; let mut updated_at = None ; let mut is_need_request = None ; let mut is_enabled = None ; let mut author_id = None ; let mut executor_id = None ; let mut limits = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: price :: NAME)) ; } price = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } Field :: is_need_request => { if is_need_request . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: is_need_request :: NAME)) ; } is_need_request = Some (map . next_value () ?) ; } Field :: is_enabled => { if is_enabled . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: is_enabled :: NAME)) ; } is_enabled = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: author_id :: NAME)) ; } author_id = Some (map . next_value () ?) ; } Field :: executor_id => { if executor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: executor_id :: NAME)) ; } executor_id = Some (map . next_value () ?) ; } Field :: limits => { if limits . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: limits :: NAME)) ; } limits = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: title :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: description :: NAME)) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: price :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: created_at :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: updated_at :: NAME)) ? ; let is_need_request = is_need_request . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: is_need_request :: NAME)) ? ; let is_enabled = is_enabled . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: is_enabled :: NAME)) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: author_id :: NAME)) ? ; let executor_id = executor_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: executor_id :: NAME)) ? ; let limits = limits . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task :: limits :: NAME)) ? ; Ok (Data { id , title , description , price , created_at , updated_at , is_need_request , is_enabled , author_id , executor_id , limits , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "description" , "price" , "created_at" , "updated_at" , "is_need_request" , "is_enabled" , "author_id" , "author" , "executor_id" , "executor" , "execute_logs" , "execute_requests" , "limits"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: user :: Data } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < executor :: Data > } ; (@ field_type ; executor) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; execute_logs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < execute_logs :: Data > } ; (@ field_type ; execute_logs) => { Vec < crate :: prisma :: task_execute_log :: Data > } ; (@ field_type ; execute_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < execute_requests :: Data > } ; (@ field_type ; execute_requests) => { Vec < crate :: prisma :: task_execute_request :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Task" , available relations are "author, executor, execute_logs, execute_requests")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; execute_logs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_log :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; execute_requests : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task_execute_request :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: author :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: executor :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: executor :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; execute_logs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: execute_logs :: Include :: $ selection_mode (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; execute_logs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: execute_logs :: Include :: Fetch (crate :: prisma :: task_execute_log :: ManyArgs :: new (crate :: prisma :: task_execute_log :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; execute_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: execute_requests :: Include :: $ selection_mode (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; execute_requests $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task :: IncludeParam > :: into (crate :: prisma :: task :: execute_requests :: Include :: Fetch (crate :: prisma :: task_execute_request :: ManyArgs :: new (crate :: prisma :: task_execute_request :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; is_need_request) => { "is_need_request" } ; (@ field_serde_name ; is_enabled) => { "is_enabled" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; execute_logs) => { "execute_logs" } ; (@ field_serde_name ; execute_requests) => { "execute_requests" } ; (@ field_serde_name ; limits) => { "limits" } ; }
    pub use _include_task as include;
    pub enum IncludeParam {
        Id(id::Include),
        Title(title::Include),
        Description(description::Include),
        Price(price::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
        IsNeedRequest(is_need_request::Include),
        IsEnabled(is_enabled::Include),
        AuthorId(author_id::Include),
        Author(author::Include),
        ExecutorId(executor_id::Include),
        Executor(executor::Include),
        ExecuteLogs(execute_logs::Include),
        ExecuteRequests(execute_requests::Include),
        Limits(limits::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
                Self::IsNeedRequest(data) => data.to_selection(),
                Self::IsEnabled(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ExecuteLogs(data) => data.to_selection(),
                Self::ExecuteRequests(data) => data.to_selection(),
                Self::Limits(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_task { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: task struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "title")] pub title : String , # [serde (rename = "description")] pub description : String , # [serde (rename = "price")] pub price : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "is_need_request")] pub is_need_request : bool , # [serde (rename = "is_enabled")] pub is_enabled : bool , # [serde (rename = "author_id")] pub author_id : i32 , # [serde (rename = "executor_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub executor_id : Option < i32 > , # [serde (rename = "limits")] pub limits : :: prisma_client_rust :: serde_json :: Value } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_task as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "price")]
        pub price: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "is_need_request")]
        pub is_need_request: bool,
        #[serde(rename = "is_enabled")]
        pub is_enabled: bool,
        #[serde(rename = "author_id")]
        pub author_id: i32,
        #[serde(rename = "author")]
        pub author: Option<Box<super::user::Data>>,
        #[serde(rename = "executor_id")]
        pub executor_id: Option<i32>,
        #[serde(
            rename = "executor",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub executor: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "execute_logs")]
        pub execute_logs: Option<Vec<super::task_execute_log::Data>>,
        #[serde(rename = "execute_requests")]
        pub execute_requests: Option<Vec<super::task_execute_request::Data>>,
        #[serde(rename = "limits")]
        pub limits: ::prisma_client_rust::serde_json::Value,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
        pub fn executor(
            &self,
        ) -> Result<Option<&super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.executor
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(executor),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn execute_logs(
            &self,
        ) -> Result<
            &Vec<super::task_execute_log::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.execute_logs
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(execute_logs),
                ))
        }
        pub fn execute_requests(
            &self,
        ) -> Result<
            &Vec<super::task_execute_request::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.execute_requests.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(execute_requests)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Author(super::user::UniqueArgs),
        Executor(super::user::UniqueArgs),
        ExecuteLogs(super::task_execute_log::ManyArgs),
        ExecuteRequests(super::task_execute_request::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Author(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
                WithParam::Executor(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(executor::NAME, None, [], selections)
                }
                WithParam::ExecuteLogs(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        execute_logs::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::ExecuteRequests(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        execute_requests::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetTitle(String),
        SetDescription(String),
        SetPrice(i32),
        IncrementPrice(i32),
        DecrementPrice(i32),
        MultiplyPrice(i32),
        DividePrice(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetIsNeedRequest(bool),
        SetIsEnabled(bool),
        SetAuthorId(i32),
        IncrementAuthorId(i32),
        DecrementAuthorId(i32),
        MultiplyAuthorId(i32),
        DivideAuthorId(i32),
        ConnectAuthor(super::user::UniqueWhereParam),
        SetExecutorId(Option<i32>),
        IncrementExecutorId(i32),
        DecrementExecutorId(i32),
        MultiplyExecutorId(i32),
        DivideExecutorId(i32),
        ConnectExecutor(super::user::UniqueWhereParam),
        DisconnectExecutor,
        ConnectExecuteLogs(Vec<super::task_execute_log::UniqueWhereParam>),
        DisconnectExecuteLogs(Vec<super::task_execute_log::UniqueWhereParam>),
        SetExecuteLogs(Vec<super::task_execute_log::UniqueWhereParam>),
        ConnectExecuteRequests(Vec<super::task_execute_request::UniqueWhereParam>),
        DisconnectExecuteRequests(Vec<super::task_execute_request::UniqueWhereParam>),
        SetExecuteRequests(Vec<super::task_execute_request::UniqueWhereParam>),
        SetLimits(::prisma_client_rust::serde_json::Value),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDescription(value) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedAt(value) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetIsNeedRequest(value) => (
                    is_need_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetIsEnabled(value) => (
                    is_enabled::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAuthor(where_param) => (
                    author::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectExecutor(where_param) => (
                    executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectExecutor => (
                    executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectExecuteLogs(where_params) => (
                    execute_logs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectExecuteLogs(where_params) => (
                    execute_logs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExecuteLogs(where_params) => (
                    execute_logs::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_log::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectExecuteRequests(where_params) => (
                    execute_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectExecuteRequests(where_params) => (
                    execute_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExecuteRequests(where_params) => (
                    execute_requests::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::task_execute_request::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLimits(value) => (
                    limits::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Json(
                        ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                    ),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Title(String),
        Description(String),
        Price(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        IsNeedRequest(bool),
        IsEnabled(bool),
        AuthorId(i32),
        ExecutorId(Option<i32>),
        Limits(::prisma_client_rust::serde_json::Value),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Description(value) => Self::SetDescription(value),
                UncheckedSetParam::Price(value) => Self::SetPrice(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
                UncheckedSetParam::IsNeedRequest(value) => Self::SetIsNeedRequest(value),
                UncheckedSetParam::IsEnabled(value) => Self::SetIsEnabled(value),
                UncheckedSetParam::AuthorId(value) => Self::SetAuthorId(value),
                UncheckedSetParam::ExecutorId(value) => Self::SetExecutorId(value),
                UncheckedSetParam::Limits(value) => Self::SetLimits(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
        Price(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
        IsNeedRequest(::prisma_client_rust::Direction),
        IsEnabled(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        ExecutorId(::prisma_client_rust::Direction),
        Limits(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Description(direction) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Price(direction) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::UpdatedAt(direction) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::IsNeedRequest(direction) => (
                    is_need_request::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::IsEnabled(direction) => (
                    is_enabled::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::AuthorId(direction) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::ExecutorId(direction) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Limits(direction) => (
                    limits::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Title(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringFilter),
        Price(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
        IsNeedRequest(_prisma::read_filters::BoolFilter),
        IsEnabled(_prisma::read_filters::BoolFilter),
        AuthorId(_prisma::read_filters::IntFilter),
        AuthorIs(Vec<super::user::WhereParam>),
        AuthorIsNot(Vec<super::user::WhereParam>),
        ExecutorId(_prisma::read_filters::IntNullableFilter),
        ExecutorIsNull,
        ExecutorIs(Vec<super::user::WhereParam>),
        ExecutorIsNot(Vec<super::user::WhereParam>),
        ExecuteLogsSome(Vec<super::task_execute_log::WhereParam>),
        ExecuteLogsEvery(Vec<super::task_execute_log::WhereParam>),
        ExecuteLogsNone(Vec<super::task_execute_log::WhereParam>),
        ExecuteRequestsSome(Vec<super::task_execute_request::WhereParam>),
        ExecuteRequestsEvery(Vec<super::task_execute_request::WhereParam>),
        ExecuteRequestsNone(Vec<super::task_execute_request::WhereParam>),
        Limits(_prisma::read_filters::JsonFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::Price(value) => (price::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
                Self::IsNeedRequest(value) => (is_need_request::NAME, value.into()),
                Self::IsEnabled(value) => (is_enabled::NAME, value.into()),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutorId(value) => (executor_id::NAME, value.into()),
                Self::ExecutorIsNull => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ExecutorIs(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutorIsNot(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteLogsSome(where_params) => (
                    execute_logs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteLogsEvery(where_params) => (
                    execute_logs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteLogsNone(where_params) => (
                    execute_logs::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteRequestsSome(where_params) => (
                    execute_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteRequestsEvery(where_params) => (
                    execute_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecuteRequestsNone(where_params) => (
                    execute_requests::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Limits(value) => (limits::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(description::NAME),
                ::prisma_client_rust::sel(price::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
                ::prisma_client_rust::sel(is_need_request::NAME),
                ::prisma_client_rust::sel(is_enabled::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(executor_id::NAME),
                ::prisma_client_rust::sel(limits::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            description: String,
            price: i32,
            author: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                description::set(description),
                price::set(price),
                author::connect(author),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            title: String,
            description: String,
            price: i32,
            author_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                description::set(description),
                price::set(price),
                author_id::set(author_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, i32, i32, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(title, description, price, author_id, mut _params)| {
                    _params.extend([
                        title::set(title),
                        description::set(description),
                        price::set(price),
                        author_id::set(author_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (title, description, price, author, mut _params): (
                String,
                String,
                i32,
                super::user::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                title::set(title),
                description::set(description),
                price::set(price),
                author::connect(author),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod task_execute_log {

    use super::*;
    pub const NAME: &str = "TaskExecuteLog";
    pub mod id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod task_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "task_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTaskId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TaskId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TaskId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TaskId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, TaskId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTaskId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTaskId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTaskId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTaskId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::TaskId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::TaskId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod task {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "task";
        pub struct Fetch(pub task::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Task(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(task::UniqueArgs::new())
        }
        pub struct Connect(task::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTask(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: task::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TaskIs(value)
        }
        pub fn is_not(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TaskIsNot(value)
        }
        pub enum Include {
            Select(Vec<task::SelectParam>),
            Include(Vec<task::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Task(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("task", None, [], selections)
            }
            pub fn select(nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<task::SelectParam>),
            Include(Vec<task::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Task(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("task", None, [], selections)
            }
            pub fn select(nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod price {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "price";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPrice(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Price(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Price(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Price(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Price, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPrice(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPrice(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPrice(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePrice(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Price(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Price(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod executor_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "executor_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExecutorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExecutorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExecutorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ExecutorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ExecutorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementExecutorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementExecutorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyExecutorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideExecutorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecutorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecutorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod executor {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "executor";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Executor(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecutor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Executor(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Executor(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod approver_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "approver_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetApproverId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ApproverId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ApproverId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ApproverId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ApproverId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementApproverId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementApproverId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyApproverId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideApproverId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ApproverId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ApproverId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod approver {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "approver";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Approver(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectApprover(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectApprover
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ApproverIsNull
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ApproverIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ApproverIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Approver(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("approver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Approver(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("approver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod approved {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "approved";
        pub struct Set(pub Option<bool>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetApproved(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Approved(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Approved(direction)
        }
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::Approved(_prisma::read_filters::BoolNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolNullableFilter,
            Approved,
            {
                fn not(_: Option<bool>) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Approved(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Approved(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::CreatedAt(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::CreatedAt(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        task: super::task::UniqueWhereParam,
        price: i32,
        executor: super::user::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::task::UniqueWhereParam,
        i32,
        super::user::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (task, price, executor, _params)
    }
    pub fn create_unchecked(
        task_id: i32,
        price: i32,
        executor_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (task_id, price, executor_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_task_execute_log { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task_execute_log :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task_execute_log :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $crate :: prisma :: task_execute_log :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task_execute_log :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task_execute_log :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , task_id , task , price , executor_id , executor , approver_id , approver , approved , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: task_execute_log :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task_execute_log :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task_execute_log :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task_execute_log :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "task_id" , "task" , "price" , "executor_id" , "executor" , "approver_id" , "approver" , "approved" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task_execute_log :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; task_id) => { i32 } ; (@ field_type ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { task :: Data } ; (@ field_type ; task) => { crate :: prisma :: task :: Data } ; (@ field_type ; price) => { i32 } ; (@ field_type ; executor_id) => { i32 } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { executor :: Data } ; (@ field_type ; executor) => { crate :: prisma :: user :: Data } ; (@ field_type ; approver_id) => { Option < i32 > } ; (@ field_type ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < approver :: Data > } ; (@ field_type ; approver) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; approved) => { Option < bool > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TaskExecuteLog" , available relations are "id, task_id, task, price, executor_id, executor, approver_id, approver, approved, created_at")) } ; (@ field_module ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: id :: Select) } ; (@ selection_field_to_selection_param ; task_id) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: task_id :: Select) } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: task :: Select :: $ selection_mode (crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: task :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; price) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: price :: Select) } ; (@ selection_field_to_selection_param ; executor_id) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: executor_id :: Select) } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: executor :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: executor :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; approver_id) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: approver_id :: Select) } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: approver :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: approver :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; approved) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: approved :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: task_execute_log :: SelectParam > :: into (crate :: prisma :: task_execute_log :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task_execute_log :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; task_id) => { "task_id" } ; (@ field_serde_name ; task) => { "task" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; approver_id) => { "approver_id" } ; (@ field_serde_name ; approver) => { "approver" } ; (@ field_serde_name ; approved) => { "approved" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_task_execute_log as select;
    pub enum SelectParam {
        Id(id::Select),
        TaskId(task_id::Select),
        Task(task::Select),
        Price(price::Select),
        ExecutorId(executor_id::Select),
        Executor(executor::Select),
        ApproverId(approver_id::Select),
        Approver(approver::Select),
        Approved(approved::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TaskId(data) => data.to_selection(),
                Self::Task(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ApproverId(data) => data.to_selection(),
                Self::Approver(data) => data.to_selection(),
                Self::Approved(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_task_execute_log { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task_execute_log :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task_execute_log :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task_execute_log :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $crate :: prisma :: task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: task_execute_log :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task_execute_log :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task_execute_log :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: task_execute_log :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { task , executor , approver } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub task_id : i32 , pub price : i32 , pub executor_id : i32 , pub approver_id : Option < i32 > , pub approved : Option < bool > , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: task_execute_log :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (task_id) , stringify ! (price) , stringify ! (executor_id) , stringify ! (approver_id) , stringify ! (approved) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task_execute_log :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: task_execute_log :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: task_id :: NAME , & self . task_id) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: price :: NAME , & self . price) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: executor_id :: NAME , & self . executor_id) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: approver_id :: NAME , & self . approver_id) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: approved :: NAME , & self . approved) ? ; state . serialize_field (crate :: prisma :: task_execute_log :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , task_id , price , executor_id , approver_id , approved , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task_execute_log :: $ field :: NAME) , + , crate :: prisma :: task_execute_log :: id :: NAME , crate :: prisma :: task_execute_log :: task_id :: NAME , crate :: prisma :: task_execute_log :: price :: NAME , crate :: prisma :: task_execute_log :: executor_id :: NAME , crate :: prisma :: task_execute_log :: approver_id :: NAME , crate :: prisma :: task_execute_log :: approved :: NAME , crate :: prisma :: task_execute_log :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task_execute_log :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: task_execute_log :: id :: NAME => Ok (Field :: id) , crate :: prisma :: task_execute_log :: task_id :: NAME => Ok (Field :: task_id) , crate :: prisma :: task_execute_log :: price :: NAME => Ok (Field :: price) , crate :: prisma :: task_execute_log :: executor_id :: NAME => Ok (Field :: executor_id) , crate :: prisma :: task_execute_log :: approver_id :: NAME => Ok (Field :: approver_id) , crate :: prisma :: task_execute_log :: approved :: NAME => Ok (Field :: approved) , crate :: prisma :: task_execute_log :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut task_id = None ; let mut price = None ; let mut executor_id = None ; let mut approver_id = None ; let mut approved = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: task_id => { if task_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: task_id :: NAME)) ; } task_id = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: price :: NAME)) ; } price = Some (map . next_value () ?) ; } Field :: executor_id => { if executor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: executor_id :: NAME)) ; } executor_id = Some (map . next_value () ?) ; } Field :: approver_id => { if approver_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: approver_id :: NAME)) ; } approver_id = Some (map . next_value () ?) ; } Field :: approved => { if approved . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: approved :: NAME)) ; } approved = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_log :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: id :: NAME)) ? ; let task_id = task_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: task_id :: NAME)) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: price :: NAME)) ? ; let executor_id = executor_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: executor_id :: NAME)) ? ; let approver_id = approver_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: approver_id :: NAME)) ? ; let approved = approved . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: approved :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_log :: created_at :: NAME)) ? ; Ok (Data { id , task_id , price , executor_id , approver_id , approved , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "task_id" , "task" , "price" , "executor_id" , "executor" , "approver_id" , "approver" , "approved" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task_execute_log :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { task :: Data } ; (@ field_type ; task) => { crate :: prisma :: task :: Data } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { executor :: Data } ; (@ field_type ; executor) => { crate :: prisma :: user :: Data } ; (@ field_type ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < approver :: Data > } ; (@ field_type ; approver) => { Option < crate :: prisma :: user :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TaskExecuteLog" , available relations are "task, executor, approver")) } ; (@ field_module ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: task :: Include :: $ selection_mode (crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: task :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: executor :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: executor :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: approver :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_log :: IncludeParam > :: into (crate :: prisma :: task_execute_log :: approver :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task_execute_log :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; task_id) => { "task_id" } ; (@ field_serde_name ; task) => { "task" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; approver_id) => { "approver_id" } ; (@ field_serde_name ; approver) => { "approver" } ; (@ field_serde_name ; approved) => { "approved" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_task_execute_log as include;
    pub enum IncludeParam {
        Id(id::Include),
        TaskId(task_id::Include),
        Task(task::Include),
        Price(price::Include),
        ExecutorId(executor_id::Include),
        Executor(executor::Include),
        ApproverId(approver_id::Include),
        Approver(approver::Include),
        Approved(approved::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TaskId(data) => data.to_selection(),
                Self::Task(data) => data.to_selection(),
                Self::Price(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ApproverId(data) => data.to_selection(),
                Self::Approver(data) => data.to_selection(),
                Self::Approved(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_task_execute_log { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: task_execute_log struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "task_id")] pub task_id : i32 , # [serde (rename = "price")] pub price : i32 , # [serde (rename = "executor_id")] pub executor_id : i32 , # [serde (rename = "approver_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub approver_id : Option < i32 > , # [serde (rename = "approved")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub approved : Option < bool > , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_task_execute_log as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "task_id")]
        pub task_id: i32,
        #[serde(rename = "task")]
        pub task: Option<Box<super::task::Data>>,
        #[serde(rename = "price")]
        pub price: i32,
        #[serde(rename = "executor_id")]
        pub executor_id: i32,
        #[serde(rename = "executor")]
        pub executor: Option<Box<super::user::Data>>,
        #[serde(rename = "approver_id")]
        pub approver_id: Option<i32>,
        #[serde(
            rename = "approver",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub approver: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "approved")]
        pub approved: Option<bool>,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {
        pub fn task(
            &self,
        ) -> Result<&super::task::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.task
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(task),
                ))
                .map(|v| v.as_ref())
        }
        pub fn executor(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.executor
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(executor),
                ))
                .map(|v| v.as_ref())
        }
        pub fn approver(
            &self,
        ) -> Result<Option<&super::user::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.approver
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(approver),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Task(super::task::UniqueArgs),
        Executor(super::user::UniqueArgs),
        Approver(super::user::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Task(args) => {
                    let mut selections =
                        <super::task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(task::NAME, None, [], selections)
                }
                WithParam::Executor(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(executor::NAME, None, [], selections)
                }
                WithParam::Approver(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(approver::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetTaskId(i32),
        IncrementTaskId(i32),
        DecrementTaskId(i32),
        MultiplyTaskId(i32),
        DivideTaskId(i32),
        ConnectTask(super::task::UniqueWhereParam),
        SetPrice(i32),
        IncrementPrice(i32),
        DecrementPrice(i32),
        MultiplyPrice(i32),
        DividePrice(i32),
        SetExecutorId(i32),
        IncrementExecutorId(i32),
        DecrementExecutorId(i32),
        MultiplyExecutorId(i32),
        DivideExecutorId(i32),
        ConnectExecutor(super::user::UniqueWhereParam),
        SetApproverId(Option<i32>),
        IncrementApproverId(i32),
        DecrementApproverId(i32),
        MultiplyApproverId(i32),
        DivideApproverId(i32),
        ConnectApprover(super::user::UniqueWhereParam),
        DisconnectApprover,
        SetApproved(Option<bool>),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectTask(where_param) => (
                    task::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePrice(value) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectExecutor(where_param) => (
                    executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetApproverId(value) => (
                    approver_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectApprover(where_param) => (
                    approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectApprover => (
                    approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetApproved(value) => (
                    approved::NAME.to_string(),
                    value
                        .map(::prisma_client_rust::PrismaValue::Boolean)
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        TaskId(i32),
        Price(i32),
        ExecutorId(i32),
        ApproverId(Option<i32>),
        Approved(Option<bool>),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::TaskId(value) => Self::SetTaskId(value),
                UncheckedSetParam::Price(value) => Self::SetPrice(value),
                UncheckedSetParam::ExecutorId(value) => Self::SetExecutorId(value),
                UncheckedSetParam::ApproverId(value) => Self::SetApproverId(value),
                UncheckedSetParam::Approved(value) => Self::SetApproved(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        TaskId(::prisma_client_rust::Direction),
        Price(::prisma_client_rust::Direction),
        ExecutorId(::prisma_client_rust::Direction),
        ApproverId(::prisma_client_rust::Direction),
        Approved(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::TaskId(direction) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Price(direction) => (
                    price::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::ExecutorId(direction) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::ApproverId(direction) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Approved(direction) => (
                    approved::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        TaskId(_prisma::read_filters::IntFilter),
        TaskIs(Vec<super::task::WhereParam>),
        TaskIsNot(Vec<super::task::WhereParam>),
        Price(_prisma::read_filters::IntFilter),
        ExecutorId(_prisma::read_filters::IntFilter),
        ExecutorIs(Vec<super::user::WhereParam>),
        ExecutorIsNot(Vec<super::user::WhereParam>),
        ApproverId(_prisma::read_filters::IntNullableFilter),
        ApproverIsNull,
        ApproverIs(Vec<super::user::WhereParam>),
        ApproverIsNot(Vec<super::user::WhereParam>),
        Approved(_prisma::read_filters::BoolNullableFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::TaskId(value) => (task_id::NAME, value.into()),
                Self::TaskIs(where_params) => (
                    task::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TaskIsNot(where_params) => (
                    task::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Price(value) => (price::NAME, value.into()),
                Self::ExecutorId(value) => (executor_id::NAME, value.into()),
                Self::ExecutorIs(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutorIsNot(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ApproverId(value) => (approver_id::NAME, value.into()),
                Self::ApproverIsNull => (
                    approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ApproverIs(where_params) => (
                    approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ApproverIsNot(where_params) => (
                    approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Approved(value) => (approved::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(task_id::NAME),
                ::prisma_client_rust::sel(price::NAME),
                ::prisma_client_rust::sel(executor_id::NAME),
                ::prisma_client_rust::sel(approver_id::NAME),
                ::prisma_client_rust::sel(approved::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            task: super::task::UniqueWhereParam,
            price: i32,
            executor: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                task::connect(task),
                price::set(price),
                executor::connect(executor),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            task_id: i32,
            price: i32,
            executor_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                task_id::set(task_id),
                price::set(price),
                executor_id::set(executor_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(task_id, price, executor_id, mut _params)| {
                    _params.extend([
                        task_id::set(task_id),
                        price::set(price),
                        executor_id::set(executor_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (task, price, executor, mut _params): (
                super::task::UniqueWhereParam,
                i32,
                super::user::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                task::connect(task),
                price::set(price),
                executor::connect(executor),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod task_execute_request {

    use super::*;
    pub const NAME: &str = "TaskExecuteRequest";
    pub mod id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod task_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "task_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTaskId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TaskId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TaskId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TaskId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, TaskId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTaskId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTaskId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTaskId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTaskId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::TaskId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::TaskId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod task {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "task";
        pub struct Fetch(pub task::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Task(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(task::UniqueArgs::new())
        }
        pub struct Connect(task::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTask(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: task::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TaskIs(value)
        }
        pub fn is_not(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TaskIsNot(value)
        }
        pub enum Include {
            Select(Vec<task::SelectParam>),
            Include(Vec<task::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Task(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("task", None, [], selections)
            }
            pub fn select(nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<task::SelectParam>),
            Include(Vec<task::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Task(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("task", None, [], selections)
            }
            pub fn select(nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod executor_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "executor_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExecutorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExecutorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExecutorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ExecutorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ExecutorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementExecutorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementExecutorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyExecutorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideExecutorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ExecutorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ExecutorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod executor {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "executor";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Executor(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectExecutor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ExecutorIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Executor(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Executor(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("executor", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod approver_id {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "approver_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetApproverId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ApproverId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ApproverId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ApproverId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ApproverId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementApproverId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementApproverId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyApproverId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideApproverId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::ApproverId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::ApproverId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod approver {
        use super::super::*;

        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "approver";
        pub struct Fetch(pub user::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Approver(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(user::UniqueArgs::new())
        }
        pub struct Connect(user::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectApprover(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: user::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ApproverIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::ApproverIsNot(value)
        }
        pub enum Include {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Approver(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("approver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<user::SelectParam>),
            Include(Vec<user::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Approver(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("approver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<user::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<user::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod approved {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "approved";
        pub struct Set(pub Option<bool>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetApproved(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Approved(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Approved(direction)
        }
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::Approved(_prisma::read_filters::BoolNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolNullableFilter,
            Approved,
            {
                fn not(_: Option<bool>) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Approved(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Approved(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;

        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::CreatedAt(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::CreatedAt(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        task: super::task::UniqueWhereParam,
        executor: super::user::UniqueWhereParam,
        approver: super::user::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::task::UniqueWhereParam,
        super::user::UniqueWhereParam,
        super::user::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (task, executor, approver, _params)
    }
    pub fn create_unchecked(
        task_id: i32,
        executor_id: i32,
        approver_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (task_id, executor_id, approver_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_task_execute_request { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task_execute_request :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task_execute_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $crate :: prisma :: task_execute_request :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task_execute_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task_execute_request :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , task_id , task , executor_id , executor , approver_id , approver , approved , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: task_execute_request :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task_execute_request :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task_execute_request :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task_execute_request :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "task_id" , "task" , "executor_id" , "executor" , "approver_id" , "approver" , "approved" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task_execute_request :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; task_id) => { i32 } ; (@ field_type ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { task :: Data } ; (@ field_type ; task) => { crate :: prisma :: task :: Data } ; (@ field_type ; executor_id) => { i32 } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { executor :: Data } ; (@ field_type ; executor) => { crate :: prisma :: user :: Data } ; (@ field_type ; approver_id) => { i32 } ; (@ field_type ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { approver :: Data } ; (@ field_type ; approver) => { crate :: prisma :: user :: Data } ; (@ field_type ; approved) => { Option < bool > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TaskExecuteRequest" , available relations are "id, task_id, task, executor_id, executor, approver_id, approver, approved, created_at")) } ; (@ field_module ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: id :: Select) } ; (@ selection_field_to_selection_param ; task_id) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: task_id :: Select) } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: task :: Select :: $ selection_mode (crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: task :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; executor_id) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: executor_id :: Select) } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: executor :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: executor :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; approver_id) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: approver_id :: Select) } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: approver :: Select :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: approver :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; approved) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: approved :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: task_execute_request :: SelectParam > :: into (crate :: prisma :: task_execute_request :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task_execute_request :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; task_id) => { "task_id" } ; (@ field_serde_name ; task) => { "task" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; approver_id) => { "approver_id" } ; (@ field_serde_name ; approver) => { "approver" } ; (@ field_serde_name ; approved) => { "approved" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_task_execute_request as select;
    pub enum SelectParam {
        Id(id::Select),
        TaskId(task_id::Select),
        Task(task::Select),
        ExecutorId(executor_id::Select),
        Executor(executor::Select),
        ApproverId(approver_id::Select),
        Approver(approver::Select),
        Approved(approved::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TaskId(data) => data.to_selection(),
                Self::Task(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ApproverId(data) => data.to_selection(),
                Self::Approver(data) => data.to_selection(),
                Self::Approved(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_task_execute_request { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: task_execute_request :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: task_execute_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$crate :: prisma :: task_execute_request :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $crate :: prisma :: task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: task_execute_request :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: task_execute_request :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: task_execute_request :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: task_execute_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { task , executor , approver } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub task_id : i32 , pub executor_id : i32 , pub approver_id : i32 , pub approved : Option < bool > , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: task_execute_request :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (task_id) , stringify ! (executor_id) , stringify ! (approver_id) , stringify ! (approved) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: task_execute_request :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: task_execute_request :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: task_execute_request :: task_id :: NAME , & self . task_id) ? ; state . serialize_field (crate :: prisma :: task_execute_request :: executor_id :: NAME , & self . executor_id) ? ; state . serialize_field (crate :: prisma :: task_execute_request :: approver_id :: NAME , & self . approver_id) ? ; state . serialize_field (crate :: prisma :: task_execute_request :: approved :: NAME , & self . approved) ? ; state . serialize_field (crate :: prisma :: task_execute_request :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , task_id , executor_id , approver_id , approved , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: task_execute_request :: $ field :: NAME) , + , crate :: prisma :: task_execute_request :: id :: NAME , crate :: prisma :: task_execute_request :: task_id :: NAME , crate :: prisma :: task_execute_request :: executor_id :: NAME , crate :: prisma :: task_execute_request :: approver_id :: NAME , crate :: prisma :: task_execute_request :: approved :: NAME , crate :: prisma :: task_execute_request :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: task_execute_request :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: task_execute_request :: id :: NAME => Ok (Field :: id) , crate :: prisma :: task_execute_request :: task_id :: NAME => Ok (Field :: task_id) , crate :: prisma :: task_execute_request :: executor_id :: NAME => Ok (Field :: executor_id) , crate :: prisma :: task_execute_request :: approver_id :: NAME => Ok (Field :: approver_id) , crate :: prisma :: task_execute_request :: approved :: NAME => Ok (Field :: approved) , crate :: prisma :: task_execute_request :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut task_id = None ; let mut executor_id = None ; let mut approver_id = None ; let mut approved = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: task_id => { if task_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: task_id :: NAME)) ; } task_id = Some (map . next_value () ?) ; } Field :: executor_id => { if executor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: executor_id :: NAME)) ; } executor_id = Some (map . next_value () ?) ; } Field :: approver_id => { if approver_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: approver_id :: NAME)) ; } approver_id = Some (map . next_value () ?) ; } Field :: approved => { if approved . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: approved :: NAME)) ; } approved = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: task_execute_request :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: id :: NAME)) ? ; let task_id = task_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: task_id :: NAME)) ? ; let executor_id = executor_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: executor_id :: NAME)) ? ; let approver_id = approver_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: approver_id :: NAME)) ? ; let approved = approved . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: approved :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: task_execute_request :: created_at :: NAME)) ? ; Ok (Data { id , task_id , executor_id , approver_id , approved , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "task_id" , "task" , "executor_id" , "executor" , "approver_id" , "approver" , "approved" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: task_execute_request :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { task :: Data } ; (@ field_type ; task) => { crate :: prisma :: task :: Data } ; (@ field_type ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { executor :: Data } ; (@ field_type ; executor) => { crate :: prisma :: user :: Data } ; (@ field_type ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { approver :: Data } ; (@ field_type ; approver) => { crate :: prisma :: user :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TaskExecuteRequest" , available relations are "task, executor, approver")) } ; (@ field_module ; task : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: task :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; executor : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; approver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: task :: Include :: $ selection_mode (crate :: prisma :: task :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; task $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: task :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: executor :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; executor $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: executor :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: approver :: Include :: $ selection_mode (crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; approver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: task_execute_request :: IncludeParam > :: into (crate :: prisma :: task_execute_request :: approver :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: task_execute_request :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; task_id) => { "task_id" } ; (@ field_serde_name ; task) => { "task" } ; (@ field_serde_name ; executor_id) => { "executor_id" } ; (@ field_serde_name ; executor) => { "executor" } ; (@ field_serde_name ; approver_id) => { "approver_id" } ; (@ field_serde_name ; approver) => { "approver" } ; (@ field_serde_name ; approved) => { "approved" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_task_execute_request as include;
    pub enum IncludeParam {
        Id(id::Include),
        TaskId(task_id::Include),
        Task(task::Include),
        ExecutorId(executor_id::Include),
        Executor(executor::Include),
        ApproverId(approver_id::Include),
        Approver(approver::Include),
        Approved(approved::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TaskId(data) => data.to_selection(),
                Self::Task(data) => data.to_selection(),
                Self::ExecutorId(data) => data.to_selection(),
                Self::Executor(data) => data.to_selection(),
                Self::ApproverId(data) => data.to_selection(),
                Self::Approver(data) => data.to_selection(),
                Self::Approved(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_task_execute_request { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: task_execute_request struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "task_id")] pub task_id : i32 , # [serde (rename = "executor_id")] pub executor_id : i32 , # [serde (rename = "approver_id")] pub approver_id : i32 , # [serde (rename = "approved")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub approved : Option < bool > , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_task_execute_request as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "task_id")]
        pub task_id: i32,
        #[serde(rename = "task")]
        pub task: Option<Box<super::task::Data>>,
        #[serde(rename = "executor_id")]
        pub executor_id: i32,
        #[serde(rename = "executor")]
        pub executor: Option<Box<super::user::Data>>,
        #[serde(rename = "approver_id")]
        pub approver_id: i32,
        #[serde(rename = "approver")]
        pub approver: Option<Box<super::user::Data>>,
        #[serde(rename = "approved")]
        pub approved: Option<bool>,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {
        pub fn task(
            &self,
        ) -> Result<&super::task::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.task
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(task),
                ))
                .map(|v| v.as_ref())
        }
        pub fn executor(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.executor
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(executor),
                ))
                .map(|v| v.as_ref())
        }
        pub fn approver(
            &self,
        ) -> Result<&super::user::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.approver
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(approver),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Task(super::task::UniqueArgs),
        Executor(super::user::UniqueArgs),
        Approver(super::user::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Task(args) => {
                    let mut selections =
                        <super::task::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(task::NAME, None, [], selections)
                }
                WithParam::Executor(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(executor::NAME, None, [], selections)
                }
                WithParam::Approver(args) => {
                    let mut selections =
                        <super::user::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(approver::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetTaskId(i32),
        IncrementTaskId(i32),
        DecrementTaskId(i32),
        MultiplyTaskId(i32),
        DivideTaskId(i32),
        ConnectTask(super::task::UniqueWhereParam),
        SetExecutorId(i32),
        IncrementExecutorId(i32),
        DecrementExecutorId(i32),
        MultiplyExecutorId(i32),
        DivideExecutorId(i32),
        ConnectExecutor(super::user::UniqueWhereParam),
        SetApproverId(i32),
        IncrementApproverId(i32),
        DecrementApproverId(i32),
        MultiplyApproverId(i32),
        DivideApproverId(i32),
        ConnectApprover(super::user::UniqueWhereParam),
        SetApproved(Option<bool>),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTaskId(value) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectTask(where_param) => (
                    task::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::task::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideExecutorId(value) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectExecutor(where_param) => (
                    executor::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideApproverId(value) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectApprover(where_param) => (
                    approver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::user::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetApproved(value) => (
                    approved::NAME.to_string(),
                    value
                        .map(::prisma_client_rust::PrismaValue::Boolean)
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        TaskId(i32),
        ExecutorId(i32),
        ApproverId(i32),
        Approved(Option<bool>),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::TaskId(value) => Self::SetTaskId(value),
                UncheckedSetParam::ExecutorId(value) => Self::SetExecutorId(value),
                UncheckedSetParam::ApproverId(value) => Self::SetApproverId(value),
                UncheckedSetParam::Approved(value) => Self::SetApproved(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        TaskId(::prisma_client_rust::Direction),
        ExecutorId(::prisma_client_rust::Direction),
        ApproverId(::prisma_client_rust::Direction),
        Approved(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::TaskId(direction) => (
                    task_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::ExecutorId(direction) => (
                    executor_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::ApproverId(direction) => (
                    approver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Approved(direction) => (
                    approved::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        TaskId(_prisma::read_filters::IntFilter),
        TaskIs(Vec<super::task::WhereParam>),
        TaskIsNot(Vec<super::task::WhereParam>),
        ExecutorId(_prisma::read_filters::IntFilter),
        ExecutorIs(Vec<super::user::WhereParam>),
        ExecutorIsNot(Vec<super::user::WhereParam>),
        ApproverId(_prisma::read_filters::IntFilter),
        ApproverIs(Vec<super::user::WhereParam>),
        ApproverIsNot(Vec<super::user::WhereParam>),
        Approved(_prisma::read_filters::BoolNullableFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::TaskId(value) => (task_id::NAME, value.into()),
                Self::TaskIs(where_params) => (
                    task::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TaskIsNot(where_params) => (
                    task::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutorId(value) => (executor_id::NAME, value.into()),
                Self::ExecutorIs(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ExecutorIsNot(where_params) => (
                    executor::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ApproverId(value) => (approver_id::NAME, value.into()),
                Self::ApproverIs(where_params) => (
                    approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ApproverIsNot(where_params) => (
                    approver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Approved(value) => (approved::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(task_id::NAME),
                ::prisma_client_rust::sel(executor_id::NAME),
                ::prisma_client_rust::sel(approver_id::NAME),
                ::prisma_client_rust::sel(approved::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            task: super::task::UniqueWhereParam,
            executor: super::user::UniqueWhereParam,
            approver: super::user::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                task::connect(task),
                executor::connect(executor),
                approver::connect(approver),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            task_id: i32,
            executor_id: i32,
            approver_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                task_id::set(task_id),
                executor_id::set(executor_id),
                approver_id::set(approver_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(task_id, executor_id, approver_id, mut _params)| {
                    _params.extend([
                        task_id::set(task_id),
                        executor_id::set(executor_id),
                        approver_id::set(approver_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (task, executor, approver, mut _params): (
                super::task::UniqueWhereParam,
                super::user::UniqueWhereParam,
                super::user::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                task::connect(task),
                executor::connect(executor),
                approver::connect(approver),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self.0 }
        }
        pub fn invite(&self) -> super::invite::Actions {
            super::invite::Actions { client: &self.0 }
        }
        pub fn task(&self) -> super::task::Actions {
            super::task::Actions { client: &self.0 }
        }
        pub fn task_execute_log(&self) -> super::task_execute_log::Actions {
            super::task_execute_log::Actions { client: &self.0 }
        }
        pub fn task_execute_request(&self) -> super::task_execute_request::Actions {
            super::task_execute_request::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum InviteScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "from_id")]
        FromId,
        #[serde(rename = "token")]
        Token,
    }
    impl ToString for InviteScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::FromId => "from_id".to_string(),
                Self::Token => "token".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum JsonNullValueFilter {
        #[serde(rename = "DbNull")]
        DbNull,
        #[serde(rename = "JsonNull")]
        JsonNull,
        #[serde(rename = "AnyNull")]
        AnyNull,
    }
    impl ToString for JsonNullValueFilter {
        fn to_string(&self) -> String {
            match self {
                Self::DbNull => "DbNull".to_string(),
                Self::JsonNull => "JsonNull".to_string(),
                Self::AnyNull => "AnyNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum JsonNullValueInput {
        #[serde(rename = "JsonNull")]
        JsonNull,
    }
    impl ToString for JsonNullValueInput {
        fn to_string(&self) -> String {
            match self {
                Self::JsonNull => "JsonNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TaskExecuteLogScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "task_id")]
        TaskId,
        #[serde(rename = "price")]
        Price,
        #[serde(rename = "executor_id")]
        ExecutorId,
        #[serde(rename = "approver_id")]
        ApproverId,
        #[serde(rename = "approved")]
        Approved,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for TaskExecuteLogScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::TaskId => "task_id".to_string(),
                Self::Price => "price".to_string(),
                Self::ExecutorId => "executor_id".to_string(),
                Self::ApproverId => "approver_id".to_string(),
                Self::Approved => "approved".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TaskExecuteRequestScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "task_id")]
        TaskId,
        #[serde(rename = "executor_id")]
        ExecutorId,
        #[serde(rename = "approver_id")]
        ApproverId,
        #[serde(rename = "approved")]
        Approved,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for TaskExecuteRequestScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::TaskId => "task_id".to_string(),
                Self::ExecutorId => "executor_id".to_string(),
                Self::ApproverId => "approver_id".to_string(),
                Self::Approved => "approved".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TaskScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "price")]
        Price,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
        #[serde(rename = "is_need_request")]
        IsNeedRequest,
        #[serde(rename = "is_enabled")]
        IsEnabled,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "executor_id")]
        ExecutorId,
        #[serde(rename = "limits")]
        Limits,
    }
    impl ToString for TaskScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Title => "title".to_string(),
                Self::Description => "description".to_string(),
                Self::Price => "price".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
                Self::IsNeedRequest => "is_need_request".to_string(),
                Self::IsEnabled => "is_enabled".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::ExecutorId => "executor_id".to_string(),
                Self::Limits => "limits".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "password")]
        Password,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "partner_id")]
        PartnerId,
        #[serde(rename = "balance")]
        Balance,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Email => "email".to_string(),
                Self::Password => "password".to_string(),
                Self::Name => "name".to_string(),
                Self::PartnerId => "partner_id".to_string(),
                Self::Balance => "balance".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl From<IntFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: IntFilter) -> Self {
                match val {
                    IntFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    IntFilter::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    IntFilter::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    IntFilter::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntFilter::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntFilter::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntFilter::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum IntNullableFilter {
            Equals(Option<i32>),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(Option<i32>),
        }
        impl From<IntNullableFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: IntNullableFilter) -> Self {
                match val {
                    IntNullableFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    IntNullableFilter::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    IntNullableFilter::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    IntNullableFilter::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntNullableFilter::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntNullableFilter::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntNullableFilter::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    IntNullableFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl From<StringFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: StringFilter) -> Self {
                match val {
                    StringFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    StringFilter::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    StringFilter::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    StringFilter::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    StringFilter::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    StringFilter::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    StringFilter::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    StringFilter::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    StringFilter::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    StringFilter::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    StringFilter::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    StringFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl From<DateTimeFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: DateTimeFilter) -> Self {
                match val {
                    DateTimeFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    DateTimeFilter::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::DateTime)
                                    .collect(),
                            ),
                        )])
                    }
                    DateTimeFilter::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::DateTime)
                                    .collect(),
                            ),
                        )])
                    }
                    DateTimeFilter::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    DateTimeFilter::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    DateTimeFilter::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    DateTimeFilter::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    DateTimeFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl From<BoolFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: BoolFilter) -> Self {
                match val {
                    BoolFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    BoolFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolNullableFilter {
            Equals(Option<bool>),
            Not(Option<bool>),
        }
        impl From<BoolNullableFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: BoolNullableFilter) -> Self {
                match val {
                    BoolNullableFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(::prisma_client_rust::PrismaValue::Boolean)
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    BoolNullableFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(::prisma_client_rust::PrismaValue::Boolean)
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum JsonFilter {
            Equals(::prisma_client_rust::serde_json::Value),
            Path(Vec<String>),
            StringContains(String),
            StringStartsWith(String),
            StringEndsWith(String),
            ArrayContains(Option<::prisma_client_rust::serde_json::Value>),
            ArrayStartsWith(Option<::prisma_client_rust::serde_json::Value>),
            ArrayEndsWith(Option<::prisma_client_rust::serde_json::Value>),
            Lt(::prisma_client_rust::serde_json::Value),
            Lte(::prisma_client_rust::serde_json::Value),
            Gt(::prisma_client_rust::serde_json::Value),
            Gte(::prisma_client_rust::serde_json::Value),
            Not(::prisma_client_rust::serde_json::Value),
        }
        impl From<JsonFilter> for ::prisma_client_rust::SerializedWhereValue {
            fn from(val: JsonFilter) -> Self {
                match val {
                    JsonFilter::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Json(
                                ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                            ),
                        )])
                    }
                    JsonFilter::Path(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "path".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    JsonFilter::StringContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    JsonFilter::StringStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_starts_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    JsonFilter::StringEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_ends_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    JsonFilter::ArrayContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_contains".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    JsonFilter::ArrayStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_starts_with".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    JsonFilter::ArrayEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_ends_with".to_string(),
                            value
                                .map(|value| {
                                    ::prisma_client_rust::PrismaValue::Json(
                                        ::prisma_client_rust::serde_json::to_string(&value)
                                            .unwrap(),
                                    )
                                })
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    JsonFilter::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    JsonFilter::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    JsonFilter::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    JsonFilter::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    JsonFilter::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            ::prisma_client_rust::serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
